using System.Reflection;
using System.Text.Json;
using Hl7.Fhir.Model;
using Hl7.Fhir.FhirPath;
using Hl7.FhirPath;
using Hl7.Fhir.ElementModel;
using Microsoft.Extensions.Logging;
using Pss.FhirProcessor.Engine.Interfaces;
using Pss.FhirProcessor.Engine.Models;

namespace Pss.FhirProcessor.Engine.Services;

/// <summary>
/// Provides advisory hints about HL7 FHIR required fields.
/// This is non-blocking and non-enforcing - purely informational.
/// Spec hints are auto-generated from HL7 StructureDefinitions with manual JSON fallback.
/// </summary>
public class SpecHintService : ISpecHintService
{
    private readonly Dictionary<string, SpecHintCatalog> _catalogCache = new();
    private readonly SemaphoreSlim _cacheLock = new(1, 1);
    private readonly FhirPathCompiler _compiler;
    private readonly Hl7SpecHintGenerator? _generator;
    private readonly ILogger<SpecHintService>? _logger;

    // Flag to prefer auto-generated hints over manual JSON
    private readonly bool _useAutoGeneratedHints = true;

    public SpecHintService()
    {
        _compiler = new FhirPathCompiler();
    }

    // Constructor with dependency injection (for testing and advanced usage)
    public SpecHintService(Hl7SpecHintGenerator generator, ILogger<SpecHintService> logger)
    {
        _compiler = new FhirPathCompiler();
        _generator = generator;
        _logger = logger;
    }

    public async Task<List<SpecHintIssue>> CheckAsync(Bundle bundle, string fhirVersion, CancellationToken cancellationToken = default)
    {
        var issues = new List<SpecHintIssue>();

        // Load the appropriate spec hints catalog for the FHIR version
        var catalog = await LoadCatalogAsync(fhirVersion, cancellationToken);
        if (catalog == null || catalog.Hints.Count == 0)
        {
            // No hints available for this version
            _logger?.LogWarning("No spec hints catalog loaded for FHIR version {Version}", fhirVersion);
            return issues;
        }

        _logger?.LogInformation("Checking {ResourceCount} resources against {HintCount} resource type hints",
            bundle.Entry?.Count ?? 0, catalog.Hints.Count);

        // Check each resource in the bundle
        if (bundle.Entry != null)
        {
            for (int i = 0; i < bundle.Entry.Count; i++)
            {
                var entry = bundle.Entry[i];
                if (entry.Resource == null)
                    continue;

                var resourceType = entry.Resource.TypeName;
                var resourceId = entry.Resource.Id;
                var jsonPointer = $"/entry/{i}/resource";

                // Check if we have hints for this resource type
                if (catalog.Hints.TryGetValue(resourceType, out var hints))
                {
                    _logger?.LogDebug("Checking {ResourceType} resource against {HintCount} hints",
                        resourceType, hints.Count);
                    
                    foreach (var hint in hints)
                    {
                        // METADATA-DRIVEN: Check IsConditional flag explicitly
                        if (hint.IsConditional)
                        {
                            // Conditional hint - requires condition evaluation
                            _logger?.LogDebug("Evaluating conditional hint: {Path} (condition: {Condition})",
                                hint.Path, hint.Condition);
                            var conditionalIssues = EvaluateConditionalHint(entry.Resource, hint, resourceType, resourceId, jsonPointer);
                            issues.AddRange(conditionalIssues);
                        }
                        else
                        {
                            // Simple required field - always evaluate
                            if (IsFieldMissing(entry.Resource, hint.Path))
                            {
                                issues.Add(new SpecHintIssue
                                {
                                    ResourceType = resourceType,
                                    ResourceId = resourceId,
                                    Path = $"{resourceType}.{hint.Path}",
                                    Reason = hint.Reason,
                                    Severity = hint.Severity,
                                    JsonPointer = jsonPointer,
                                    IsConditional = false,
                                    Condition = null,
                                    AppliesToEach = false
                                });
                            }
                        }
                    }
                }
            }
        }

        _logger?.LogInformation("Found {IssueCount} spec hint issues", issues.Count);
        return issues;
    }

    /// <summary>
    /// Evaluates a conditional hint - METADATA-DRIVEN.
    /// Requires IsConditional=true and valid Condition.
    /// Handles both single-value and array scenarios based on AppliesToEach flag.
    /// </summary>
    private List<SpecHintIssue> EvaluateConditionalHint(
        Resource resource,
        SpecHint hint,
        string resourceType,
        string resourceId,
        string jsonPointer)
    {
        var issues = new List<SpecHintIssue>();

        try
        {
            // SAFETY: Validate metadata before proceeding
            if (string.IsNullOrWhiteSpace(hint.Condition))
            {
                // Invalid metadata: IsConditional=true but no condition provided
                // Skip hint (don't throw exception)
                return issues;
            }

            // Evaluate the condition
            var conditionMet = EvaluateCondition(resource, hint.Condition);
            
            if (!conditionMet)
            {
                // Condition not met, skip this hint
                return issues;
            }

            // Condition is met, now check the required field
            if (hint.AppliesToEach)
            {
                // Apply validation to each item in the collection
                // Extract parent path from the full path (e.g., "communication" from "communication.language")
                var parts = hint.Path.Split('.');
                if (parts.Length < 2)
                {
                    // Invalid path for appliesToEach, fall back to simple check
                    if (IsFieldMissing(resource, hint.Path))
                    {
                        issues.Add(CreateIssue(resourceType, resourceId, hint, jsonPointer));
                    }
                    return issues;
                }

                var parentPath = parts[0];
                var childPath = string.Join(".", parts.Skip(1));

                // Get all parent elements (e.g., all communication entries)
                var parentElements = GetCollectionElements(resource, parentPath);
                
                // Check each parent element for the required child field
                for (int i = 0; i < parentElements.Count; i++)
                {
                    var parentElement = parentElements[i];
                    if (IsFieldMissingInElement(parentElement, childPath))
                    {
                        // Create issue for this specific array item with metadata
                        issues.Add(new SpecHintIssue
                        {
                            ResourceType = resourceType,
                            ResourceId = resourceId,
                            Path = $"{resourceType}.{parentPath}[{i}].{childPath}",
                            Reason = hint.Reason,
                            Severity = hint.Severity,
                            JsonPointer = $"{jsonPointer}/{parentPath}/{i}",
                            IsConditional = true,
                            Condition = hint.Condition,
                            AppliesToEach = true
                        });
                    }
                }
            }
            else
            {
                // Validate once at resource level
                if (IsFieldMissing(resource, hint.Path))
                {
                    issues.Add(CreateIssue(resourceType, resourceId, hint, jsonPointer));
                }
            }
        }
        catch
        {
            // If evaluation fails, skip this hint (conservative approach)
            // Don't emit warnings for evaluation errors
        }

        return issues;
    }

    /// <summary>
    /// Evaluates a FHIRPath condition expression
    /// Returns true if condition evaluates to true, false otherwise
    /// </summary>
    private bool EvaluateCondition(Resource resource, string condition)
    {
        try
        {
            var compiled = _compiler.Compile(condition);
            var typedElement = resource.ToTypedElement();
            var scopedNode = new ScopedNode(typedElement);
            var result = compiled(scopedNode, new EvaluationContext());
            var resultList = result.ToList();

            // Check if result is true (boolean true or non-empty collection)
            if (!resultList.Any())
                return false;

            // Check for explicit boolean true
            var firstResult = resultList.First();
            if (firstResult is ITypedElement te && te.Value is bool boolValue)
            {
                return boolValue;
            }

            // Non-empty result means condition is met
            return true;
        }
        catch
        {
            // If condition evaluation fails, assume not met (conservative)
            return false;
        }
    }

    /// <summary>
    /// Gets all elements in a collection at the specified path
    /// </summary>
    private List<ITypedElement> GetCollectionElements(Resource resource, string path)
    {
        try
        {
            var compiled = _compiler.Compile(path);
            var typedElement = resource.ToTypedElement();
            var scopedNode = new ScopedNode(typedElement);
            var result = compiled(scopedNode, new EvaluationContext());
            
            return result.OfType<ITypedElement>().ToList();
        }
        catch
        {
            return new List<ITypedElement>();
        }
    }

    /// <summary>
    /// Checks if a field is missing within a specific typed element.
    /// Evaluates FHIRPath relative to the given element.
    /// </summary>
    private bool IsFieldMissingInElement(ITypedElement element, string childPath)
    {
        try
        {
            // Compile FHIRPath expression for the child field
            var compiled = _compiler.Compile(childPath);
            
            // Create scoped node for the parent element
            var scopedNode = new ScopedNode(element);
            
            // Evaluate FHIRPath relative to this element
            var result = compiled(scopedNode, new EvaluationContext());
            var resultList = result.ToList();

            // If no results, field is missing
            if (!resultList.Any())
                return true;

            // Check if all results are empty
            return resultList.All(r => IsEmptyValue(r));
        }
        catch
        {
            // If evaluation fails, assume field exists (conservative)
            return false;
        }
    }

    /// <summary>
    /// Creates a SpecHintIssue from a hint with full metadata.
    /// Metadata drives error formatting (no path-based inference).
    /// </summary>
    private SpecHintIssue CreateIssue(string resourceType, string resourceId, SpecHint hint, string jsonPointer)
    {
        return new SpecHintIssue
        {
            ResourceType = resourceType,
            ResourceId = resourceId,
            Path = $"{resourceType}.{hint.Path}",
            Reason = hint.Reason,
            Severity = hint.Severity,
            JsonPointer = jsonPointer,
            IsConditional = hint.IsConditional,
            Condition = hint.Condition,
            AppliesToEach = hint.AppliesToEach
        };
    }

    /// <summary>
    /// Checks if a field is missing (null or empty) using FHIRPath evaluation
    /// </summary>
    private bool IsFieldMissing(Resource resource, string path)
    {
        try
        {
            // Compile the FHIRPath expression
            var compiled = _compiler.Compile(path);
            
            // Convert Resource POCO to ITypedElement
            var typedElement = resource.ToTypedElement();
            var scopedNode = new ScopedNode(typedElement);
            
            // Evaluate the FHIRPath expression
            var result = compiled(scopedNode, new EvaluationContext());
            var resultList = result.ToList();
            
            // If no results, field is missing
            if (!resultList.Any())
                return true;

            // Check if all results are empty/null
            return resultList.All(r => IsEmptyValue(r));
        }
        catch
        {
            // If FHIRPath evaluation fails, assume field exists (conservative approach)
            return false;
        }
    }

    /// <summary>
    /// Checks if a value is effectively empty.
    /// For complex types (CodeableConcept, HumanName, etc.), checks if they have children.
    /// </summary>
    private bool IsEmptyValue(object value)
    {
        if (value == null)
            return true;

        // Handle ITypedElement from FHIRPath evaluation
        if (value is ITypedElement te)
        {
            var elementValue = te.Value;
            
            // For primitive types, check the value
            if (elementValue != null)
            {
                if (elementValue is string s && string.IsNullOrWhiteSpace(s))
                    return true;
                return false; // Has non-empty primitive value
            }
            
            // For complex types (Value is null), check if has children
            // Complex types like CodeableConcept, HumanName, Address, etc. have .Value=null
            // but contain child elements. They're NOT empty if they have children.
            return !te.Children().Any();
        }

        // Handle raw string values
        if (value is string str)
            return string.IsNullOrWhiteSpace(str);

        // Handle enumerables
        if (value is System.Collections.IEnumerable enumerable && value is not string)
            return !enumerable.Cast<object>().Any();

        return false;
    }

    /// <summary>
    /// Loads the spec hints catalog for the given FHIR version.
    /// Auto-generates from HL7 StructureDefinitions if available, falls back to manual JSON.
    /// Catalogs are cached in memory after first load.
    /// </summary>
    private async Task<SpecHintCatalog?> LoadCatalogAsync(string fhirVersion, CancellationToken cancellationToken)
    {
        // Normalize version to catalog key
        var catalogKey = fhirVersion.ToUpperInvariant();
        _logger?.LogInformation("LoadCatalogAsync called for FHIR version {Version} (_useAutoGeneratedHints={UseAuto}, _generator={HasGenerator})",
            fhirVersion, _useAutoGeneratedHints, _generator != null);

        // Check cache first
        if (_catalogCache.TryGetValue(catalogKey, out var cached))
        {
            _logger?.LogDebug("Returning cached catalog for {Version}", fhirVersion);
            return cached;
        }

        await _cacheLock.WaitAsync(cancellationToken);
        try
        {
            // Double-check after acquiring lock
            if (_catalogCache.TryGetValue(catalogKey, out cached))
            {
                return cached;
            }

            SpecHintCatalog? catalog = null;

            // STRATEGY 1: Try auto-generation from HL7 StructureDefinitions
            _logger?.LogInformation("Attempting auto-generation: useAutoGen={UseAuto}, hasGenerator={HasGen}",
                _useAutoGeneratedHints, _generator != null);
            if (_useAutoGeneratedHints && _generator != null)
            {
                catalog = await TryGenerateFromStructureDefinitionsAsync(fhirVersion, catalogKey, cancellationToken);
                
                if (catalog != null && catalog.Hints.Count > 0)
                {
                    _logger?.LogInformation("Successfully auto-generated {Count} resource type hints for FHIR {Version} from HL7 StructureDefinitions",
                        catalog.Hints.Count, fhirVersion);
                }
            }

            // STRATEGY 2: Load manual catalog and merge with auto-generated hints
            var manualCatalog = await LoadManualCatalogAsync(fhirVersion, catalogKey, cancellationToken);
            
            if (manualCatalog != null && manualCatalog.Hints.Count > 0)
            {
                if (catalog == null)
                {
                    // No auto-generated hints, use manual only
                    catalog = manualCatalog;
                    _logger?.LogInformation("Using manual catalog with {Count} resource types", catalog.Hints.Count);
                }
                else
                {
                    // Merge: manual hints supplement auto-generated ones
                    foreach (var resourceType in manualCatalog.Hints.Keys)
                    {
                        if (!catalog.Hints.ContainsKey(resourceType))
                        {
                            // Add manual hints for resource types not covered by auto-generation
                            catalog.Hints[resourceType] = manualCatalog.Hints[resourceType];
                        }
                        // Note: If resourceType exists in both, auto-generated takes precedence
                    }
                    _logger?.LogInformation("Merged manual catalog: {AutoCount} auto-generated + {ManualCount} manual resource types",
                        catalog.Hints.Count - manualCatalog.Hints.Keys.Count(k => !catalog.Hints.ContainsKey(k)),
                        manualCatalog.Hints.Keys.Count(k => catalog.Hints.ContainsKey(k) == false));
                }
            }

            if (catalog != null)
            {
                _catalogCache[catalogKey] = catalog;
                return catalog;
            }

            // STRATEGY 3: Return empty catalog (graceful failure)
            _logger?.LogWarning("No hints available for FHIR version {Version}. Returning empty catalog.", fhirVersion);
            var emptyCatalog = new SpecHintCatalog { Version = fhirVersion, Hints = new() };
            _catalogCache[catalogKey] = emptyCatalog;
            return emptyCatalog;
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Failed to load spec hints for FHIR version {Version}. Returning empty catalog.", fhirVersion);
            // On error, cache empty catalog to avoid repeated failures
            var emptyCatalog = new SpecHintCatalog { Version = fhirVersion, Hints = new() };
            _catalogCache[catalogKey] = emptyCatalog;
            return emptyCatalog;
        }
        finally
        {
            _cacheLock.Release();
        }
    }

    /// <summary>
    /// Attempts to generate hints from HL7 StructureDefinition files.
    /// Returns null if generation fails or no StructureDefinitions found.
    /// </summary>
    private System.Threading.Tasks.Task<SpecHintCatalog?> TryGenerateFromStructureDefinitionsAsync(
        string fhirVersion,
        string catalogKey,
        CancellationToken cancellationToken)
    {
        try
        {
            // Determine StructureDefinition directory based on FHIR version
            var structureDefDirectory = GetStructureDefinitionDirectory(fhirVersion);
            
            if (structureDefDirectory == null || !Directory.Exists(structureDefDirectory))
            {
                _logger?.LogDebug("StructureDefinition directory not found for {Version}: {Directory}. Skipping auto-generation.",
                    fhirVersion, structureDefDirectory ?? "null");
                return System.Threading.Tasks.Task.FromResult<SpecHintCatalog?>(null);
            }

            _logger?.LogInformation("Auto-generating SPEC_HINTs from HL7 StructureDefinitions in {Directory}", structureDefDirectory);

            var hints = _generator!.GenerateHints(structureDefDirectory, fhirVersion);
            
            if (hints.Count == 0)
            {
                _logger?.LogWarning("Auto-generation completed but produced 0 hints for {Version}", fhirVersion);
                return System.Threading.Tasks.Task.FromResult<SpecHintCatalog?>(null);
            }

            var catalog = new SpecHintCatalog
            {
                Version = fhirVersion,
                Description = $"Auto-generated from HL7 FHIR {fhirVersion} StructureDefinitions",
                Hints = hints
            };

            return System.Threading.Tasks.Task.FromResult<SpecHintCatalog?>(catalog);
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Failed to auto-generate hints for {Version}. Will try manual catalog.", fhirVersion);
            return System.Threading.Tasks.Task.FromResult<SpecHintCatalog?>(null);
        }
    }

    /// <summary>
    /// Determines the directory containing StructureDefinition JSON files for a given FHIR version.
    /// Checks multiple common locations.
    /// </summary>
    private string? GetStructureDefinitionDirectory(string fhirVersion)
    {
        var normalizedVersion = fhirVersion.ToUpperInvariant();
        
        // Get base directory (project root or bin directory)
        var baseDirectory = AppContext.BaseDirectory;
        _logger?.LogDebug("BaseDirectory for StructureDefinition search: {BaseDirectory}", baseDirectory);
        
        // Try multiple potential locations
        // UPDATED: Changed from "StructureDefinitions" to root fhir/r4 folder (contains resources/, base/, datatypes/ subdirectories)
        var potentialPaths = new[]
        {
            // Development: bin/Debug/net8.0/ -> ../../../../../specs/fhir/r4/
            Path.Combine(baseDirectory, "..", "..", "..", "..", "..", "specs", "fhir", normalizedVersion.ToLower()),
            
            // Published: /specs/fhir/r4/ (relative to bin)
            Path.Combine(baseDirectory, "specs", "fhir", normalizedVersion.ToLower()),
            
            // Alternative: /specs/fhir/R4/
            Path.Combine(baseDirectory, "specs", "fhir", normalizedVersion),
            
            // Development alternate: from Engine project (4 levels up)
            Path.Combine(baseDirectory, "..", "..", "..", "..", "specs", "fhir", normalizedVersion.ToLower())
        };

        foreach (var path in potentialPaths)
        {
            var normalized = Path.GetFullPath(path);
            _logger?.LogDebug("Checking path: {Path} (exists: {Exists})", normalized, Directory.Exists(normalized));
            if (Directory.Exists(normalized))
            {
                _logger?.LogInformation("Found StructureDefinition directory at: {Path}", normalized);
                return normalized;
            }
        }

        _logger?.LogWarning("No StructureDefinition directory found for FHIR {Version}", fhirVersion);
        return null;
    }

    /// <summary>
    /// Loads hints from manual JSON catalog (embedded resource).
    /// This is the fallback if auto-generation is unavailable.
    /// </summary>
    private async Task<SpecHintCatalog?> LoadManualCatalogAsync(
        string fhirVersion,
        string catalogKey,
        CancellationToken cancellationToken)
    {
        try
        {
            var catalogFileName = catalogKey switch
            {
                "R4" or "4.0.1" => "fhir-spec-hints-r4.json",
                _ => null
            };

            if (catalogFileName == null)
            {
                _logger?.LogDebug("No manual catalog file defined for FHIR version {Version}", fhirVersion);
                return null;
            }

            var assembly = Assembly.GetExecutingAssembly();
            var resourceName = $"Pss.FhirProcessor.Engine.Catalogs.{catalogFileName}";

            using var stream = assembly.GetManifestResourceStream(resourceName);
            if (stream == null)
            {
                _logger?.LogDebug("Manual catalog file not found: {ResourceName}", resourceName);
                return null;
            }

            var options = new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            };
            
            var catalog = await JsonSerializer.DeserializeAsync<SpecHintCatalog>(stream, options, cancellationToken);
            
            if (catalog != null && catalog.Hints.Count > 0)
            {
                _logger?.LogInformation("Loaded manual catalog with {Count} resource types for FHIR {Version}",
                    catalog.Hints.Count, fhirVersion);
                return catalog;
            }

            return null;
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Failed to load manual catalog for {Version}", fhirVersion);
            return null;
        }
    }
}
