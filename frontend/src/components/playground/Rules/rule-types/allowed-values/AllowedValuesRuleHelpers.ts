import type { Rule } from '../../../../../types/rightPanelProps';
import type { InstanceScope } from '../../common/InstanceScope.types';
import { composeInstanceScopedPath } from '../../common/InstanceScope.utils';
import { validateFieldPath } from '../../../../../utils/fieldPathValidator';

/**
 * ALLOWED VALUES RULE HELPERS
 * 
 * Build and parse AllowedValues rules for the unified RuleForm architecture.
 * 
 * PHASE 4: Stores instanceScope and fieldPath as structured properties
 * FIXED ERROR CODE: VALUE_NOT_ALLOWED (cannot be changed by user)
 * 
 * Rule Structure:
 * - type: "AllowedValues"
 * - instanceScope: Structured instance scope object
 * - fieldPath: Resource-relative field path
 * - path: Legacy composed path (backward compat)
 * - params.values: Array of allowed values
 * - errorCode: "VALUE_NOT_ALLOWED" (fixed)
 */

interface BuildAllowedValuesRuleParams {
  resourceType: string;
  instanceScope: InstanceScope;
  fieldPath: string;
  allowedValues: string[];
  severity: 'error' | 'warning' | 'information';
  errorCode: string;
  userHint?: string;
}

/**
 * Compose full FHIRPath from components.
 * Used for backward compatibility with legacy path field.
 */
function composeFhirPath(
  resourceType: string,
  instanceScope: InstanceScope,
  fieldPath: string
): string {
  const scopePath = composeInstanceScopedPath(resourceType, instanceScope);
  return `${scopePath}.${fieldPath}`;
}

/**
 * Build an AllowedValues rule from form data.
 * PHASE 4: Stores instanceScope and fieldPath as separate properties
 */
export function buildAllowedValuesRule(params: BuildAllowedValuesRuleParams): Rule {
  const {
    resourceType,
    instanceScope,
    fieldPath,
    allowedValues,
    severity,
    errorCode,
    userHint,
  } = params;

  // Validate field path (should be resource-relative)
  const validation = validateFieldPath(fieldPath);
  if (!validation.isValid) {
    throw new Error(`Invalid field path: ${validation.errorMessage}`);
  }

  // ✅ NEW: Store structured fields
  // ⚠️ Also compose legacy path for backward compatibility
  const legacyPath = composeFhirPath(resourceType, instanceScope, fieldPath);

  return {
    id: `rule-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    type: 'AllowedValues',
    resourceType,
    
    // ✅ NEW STRUCTURED FIELDS (PHASE 4)
    instanceScope,
    fieldPath,
    
    // ⚠️ DEPRECATED: Legacy path for backward compatibility
    path: legacyPath,
    
    severity,
    errorCode,
    params: {
      values: allowedValues,
    },
    userHint,
    message: '', // Will be generated by backend
    isMessageCustomized: false,
  };
}

/**
 * Parse an AllowedValues rule for editing.
 * Extracts field path and allowed values from rule definition.
 */
export function parseAllowedValuesRule(rule: Rule): {
  fieldPath: string;
  allowedValues: string[];
} {
  // Extract field path from full path
  const pathParts = rule.path?.split('.') || [];
  const fieldPath = pathParts.slice(1).join('.');
  
  const allowedValues = Array.isArray(rule.params?.values) 
    ? rule.params.values.map((v: any) => v.toString())
    : [];

  return {
    fieldPath,
    allowedValues,
  };
}
