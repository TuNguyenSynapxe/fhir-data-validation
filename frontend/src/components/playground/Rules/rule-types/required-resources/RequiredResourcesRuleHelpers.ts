import type { Rule } from '../../../../../types/rightPanelProps';
import type { ResourceRequirement } from './RequiredResourcesConfigSection';

/**
 * REQUIRED RESOURCES RULE HELPERS
 * 
 * Build and parse RequiredResources rules for the unified RuleForm architecture.
 * 
 * FIXED ERROR CODE: REQUIRED_RESOURCE_MISSING (cannot be overridden)
 * 
 * Rule Structure:
 * - type: "RequiredResources"
 * - path: "Bundle" (bundle-level validation)
 * - params.requirements: Array<{ resourceType, min, max? }>
 * - errorCode: REQUIRED_RESOURCE_MISSING (fixed)
 * 
 * Semantics:
 * - mode: "min" → { min: count } → "At least count"
 * - mode: "exact" → { min: count, max: count } → "Exactly count"
 * - NO range support (min < max)
 */

interface BuildRequiredResourcesRuleParams {
  requirements: ResourceRequirement[];
  severity: 'error' | 'warning' | 'information';
  userHint?: string;
}

/**
 * Build a RequiredResources rule from form data.
 */
export function buildRequiredResourcesRule(params: BuildRequiredResourcesRuleParams): Rule {
  const { requirements, severity, userHint } = params;

  // Convert UI requirements to backend format
  const backendRequirements = requirements.map((req) => ({
    resourceType: req.resourceType,
    min: req.count,
    ...(req.mode === 'exact' && { max: req.count }), // Only include max for exact mode
  }));

  return {
    id: `rule-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    type: 'RequiredResources',
    resourceType: 'Bundle', // Bundle-level rule
    path: 'Bundle',
    severity,
    errorCode: 'REQUIRED_RESOURCE_MISSING', // Fixed errorCode
    params: {
      requirements: backendRequirements,
    },
    userHint,
    message: '', // Will be generated by backend
    isMessageCustomized: false,
  };
}

/**
 * Parse a RequiredResources rule for editing.
 * Extracts requirements array and infers mode from min/max.
 */
export function parseRequiredResourcesRule(rule: Rule): {
  requirements: ResourceRequirement[];
} {
  const backendRequirements = (rule.params?.requirements as any[]) || [];

  // Convert backend requirements to UI format
  const requirements: ResourceRequirement[] = backendRequirements.map((req) => {
    const hasMax = req.max !== undefined && req.max !== null;
    const isExact = hasMax && req.max === req.min;

    return {
      resourceType: req.resourceType || 'Patient',
      mode: isExact ? 'exact' : 'min',
      count: req.min || 1,
    };
  });

  return { requirements };
}
