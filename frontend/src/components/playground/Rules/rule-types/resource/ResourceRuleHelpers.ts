import type { Rule } from '../../../../../types/rightPanelProps';
import type { ResourceRequirement, WhereFilter } from './ResourceConfigSection';

/**
 * RESOURCE RULE HELPERS
 * 
 * Build and parse Resource rules for the unified RuleForm architecture.
 * 
 * FIXED ERROR CODE: RESOURCE_REQUIREMENT_VIOLATION (cannot be overridden)
 * 
 * Rule Structure:
 * - type: "Resource"
 * - path: "Bundle" (bundle-level validation)
 * - params.requirements: Array<{ resourceType, min, max?, where? }>
 * - params.rejectUndeclaredResources: true (always enforced)
 * - errorCode: RESOURCE_REQUIREMENT_VIOLATION (fixed)
 * 
 * Semantics:
 * - mode: "min" → { min: count } → "At least count"
 * - mode: "exact" → { min: count, max: count } → "Exactly count"
 * - where: Array of FHIRPath filter conditions
 * - NO range support (min < max)
 */

interface BuildResourceRuleParams {
  requirements: ResourceRequirement[];
  severity: 'error' | 'warning' | 'information';
  userHint?: string;
}

/**
 * Build a Resource rule from form data.
 */
export function buildResourceRule(params: BuildResourceRuleParams): Rule {
  const { requirements, severity, userHint } = params;

  // Convert UI requirements to backend format
  const backendRequirements = requirements.map((req) => {
    const requirement: any = {
      resourceType: req.resourceType,
      min: req.count,
    };

    // Add max for exact mode
    if (req.mode === 'exact') {
      requirement.max = req.count;
    }

    // Add where filters if present
    if (req.where && req.where.length > 0) {
      requirement.where = req.where.map((filter) => {
        // For 'in' operator, convert comma-separated string to array
        if (filter.op === 'in') {
          const values = filter.value.split(',').map(v => v.trim()).filter(v => v.length > 0);
          return {
            path: filter.path,
            op: filter.op,
            value: values,
          };
        }
        
        return {
          path: filter.path,
          op: filter.op,
          value: filter.value,
        };
      });
    }

    return requirement;
  });

  return {
    id: `rule-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    type: 'Resource',
    resourceType: 'Bundle', // Bundle-level rule
    path: 'Bundle',
    severity,
    errorCode: 'RESOURCE_REQUIREMENT_VIOLATION', // Fixed errorCode
    params: {
      requirements: backendRequirements,
      rejectUndeclaredResources: true, // Always enforced
    },
    userHint,
    message: '', // Will be generated by backend
    isMessageCustomized: false,
  };
}

/**
 * Parse a Resource rule for editing.
 * Extracts requirements array and infers mode from min/max.
 */
export function parseResourceRule(rule: Rule): {
  requirements: ResourceRequirement[];
} {
  const backendRequirements = (rule.params?.requirements as any[]) || [];

  // Convert backend requirements to UI format
  const requirements: ResourceRequirement[] = backendRequirements.map((req) => {
    const hasMax = req.max !== undefined && req.max !== null;
    const isExact = hasMax && req.max === req.min;

    const requirement: ResourceRequirement = {
      resourceType: req.resourceType || 'Patient',
      mode: isExact ? 'exact' : 'min',
      count: req.min || 1,
    };

    // Parse where filters if present
    if (req.where && Array.isArray(req.where) && req.where.length > 0) {
      requirement.where = req.where.map((filter: any) => {
        // For 'in' operator with array value, convert back to comma-separated string
        let value = filter.value || '';
        if (filter.op === 'in' && Array.isArray(filter.value)) {
          value = filter.value.join(', ');
        }
        
        return {
          path: filter.path || '',
          op: filter.op || '=',
          value: typeof value === 'string' ? value : String(value),
        };
      });
    }

    return requirement;
  });

  return { requirements };
}
